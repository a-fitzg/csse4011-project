# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
from pyqtgraph import PlotWidget
import pyqtgraph as pg
import numpy as np
from PyQt5.QtCore import QThread, pyqtSignal
import time
from pyqtgraph.graphicsItems.ScatterPlotItem import Symbols
import asyncio
from bleak import BleakScanner
from bleak.backends.device import BLEDevice
from bleak.backends.scanner import AdvertisementData
import logging
import ctypes
from asyncqt import QEventLoop
from openpyxl import load_workbook
import scipy.optimize as opt
from sklearn.neighbors import KNeighborsClassifier 
from pykalman import KalmanFilter
from scipy.optimize import minimize

mobile1_R = None
mobile1_U = None
mobile2_R = None
mobile2_U = None
mobile3_R = None
mobile3_U = None

def simple_callback(device: BLEDevice, advertisement_data: AdvertisementData):
    
    if device.address == "E1:38:D4:CD:DE:AF" and advertisement_data.service_data:
        global mobile1_R
        global mobile1_U
        rssi_list = []
        us_list = []
        adv_bytearray = list(advertisement_data.service_data.values())[0]
        node_values = [ctypes.c_int8(adv_bytearray[i]).value for i in range(len(adv_bytearray))]
        rssi_list.extend(node_values[2:15])
        us_list.extend(node_values[15:17])
        mobile1_R = rssi_list
        mobile1_U = us_list
    if device.address == "CF:95:D7:62:5F:4D" and advertisement_data.service_data:
        global mobile2_R
        global mobile2_U
        rssi_list = []
        us_list = []
        adv_bytearray = list(advertisement_data.service_data.values())[0]
        node_values = [ctypes.c_int8(adv_bytearray[i]).value for i in range(len(adv_bytearray))]
        rssi_list.extend(node_values[2:15])
        us_list.extend(node_values[15:17])
        mobile2_R = rssi_list
        mobile2_U = us_list
    if device.address == "" and advertisement_data.service_data:
        global mobile3_R
        global mobile3_U
        rssi_list = []
        us_list = []
        adv_bytearray = list(advertisement_data.service_data.values())[0]
        node_values = [ctypes.c_int8(adv_bytearray[i]).value for i in range(len(adv_bytearray))]
        rssi_list.extend(node_values[2:15])
        us_list.extend(node_values[15:17])
        mobile3_R = rssi_list
        mobile3_U = us_list

def get_trainingmodel():
        # ITERATE_X = 8
        # ITERATE_Y = 10
        X_train = []
        Y_train = []
        # temp_x = []
        # temp_y = []
        # count = 0
        # ds = []
        # wb = load_workbook(filename=r'C:\Users\desmo\csse4011\csse4011-p3\TrainingData.xlsx')
        # sheet = wb.active
        # for r in sheet.iter_rows(min_row=1,max_row=4500,min_col=1,max_col=2,values_only=True):
        #     X_train = [int(s) for s in r[0].split(',')]
        #     Y_train = [int(s) for s in r[1].split(',')]
        wb = load_workbook(filename=r'C:\Users\desmo\csse4011\csse4011-project\apps\trainingset.xlsx')
        sheet = wb.active

        for r in sheet.iter_rows(min_row=1,max_row=37600,min_col=1,max_col=3,values_only=True):
            temp = []
            r_n = [int(s) for s in r[0].split('?')]
            temp = [int(r[1].strip('|')), int(r[2].strip('|'))]
            Y_train.append(temp)
            X_train.append(r_n)
        model = KNeighborsClassifier(n_neighbors=5)
        model.fit(X_train,Y_train)
    
        return model

def Kalman(raw_data):
        kf = KalmanFilter(initial_state_mean=[0,0], n_dim_obs=2)
        measurements = np.asarray(raw_data)  # 2 observations
        initial_state_mean = [measurements[0, 0],
                            0,
                            measurements[0, 1],
                            0]
        transition_matrix = [[1, 1, 0, 0],
                            [0, 1, 0, 0],
                            [0, 0, 1, 1],
                            [0, 0, 0, 1]]
        observation_matrix = [[1, 0, 0, 0],
                            [0, 0, 1, 0]]

        kf1 = KalmanFilter(transition_matrices = transition_matrix,
                        observation_matrices = observation_matrix,
                        initial_state_mean = initial_state_mean)
        kf1 = kf1.em(measurements, n_iter=5)
        (smoothed_state_means, smoothed_state_covariances) = kf1.smooth(measurements)
        x = smoothed_state_means[:, 0]
        y = smoothed_state_means[:, 2]
        # mean_x = mean(x)
        # mean_y = mean(y)
        # print(mean_x)
        # print(mean_y)
        # print(smoothed_state_means)
        mean_x = (sum(x)) / len(x)
        mean_y = (sum(y)) / len(y)
        return [mean_x, mean_y]

class RSSI(QThread):
    signal  = pyqtSignal('PyQt_PyObject')

    def __init__(self, loop: asyncio.AbstractEventLoop, parent = None):
        super(RSSI, self).__init__(parent)
        self.loop = loop
    
    async def run(self):
        scanner = BleakScanner()
        scanner.register_detection_callback(simple_callback)     

        while True:
            await scanner.start()
            await asyncio.sleep(0.1)
            await scanner.stop()

    def work(self):
        asyncio.ensure_future(self.run(), loop=self.loop)

class Worker(QThread):
    signal = pyqtSignal('PyQt_PyObject')

    def __init__(self):
        QThread.__init__(self)

    def rssi_dist_convert(self, rssi, ntype):
        if (ntype == 1): ## board static beacon
            dist = 10 ** ((-58 - rssi) / 30)  
            return dist
        elif (ntype == 2): ## ibeacon
            dist = 10 ** ((-72 - rssi) / 20) 

    def gps_solve(self, distances_to_station, stations_coordinates):
        def error(x, c, r):
            return sum([(np.linalg.norm(x - c[i]) - r[i]) ** 2 for i in range(len(c))])

        l = len(stations_coordinates)
        S = sum(distances_to_station)
        # compute weight vector for initial guess
        W = [((l - 1) * S) / (S - w) for w in distances_to_station]
        # get initial guess of point location
        x0 = sum([W[i] * stations_coordinates[i] for i in range(l)])
        # optimize distance from signal origin to border of spheres
        return minimize(error, x0, args=(stations_coordinates, distances_to_station), method='Nelder-Mead').x

    

    def run(self):
        model = get_trainingmodel()
        while True:
            ## feed rssi to modal
            predicted_m1 = model.predict([mobile1_R])
            print(predicted_m1)
            ## get distance from rssi value
            ## multilateration
            ## kalman filter
            ## pass value to gui
            ##  
            ## upl to dashboard
            time.sleep(1)

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(799, 600)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.graphicsView = PlotWidget(self.centralwidget)
        self.graphicsView.setGeometry(QtCore.QRect(10, 10, 551, 441))
        self.graphicsView.setObjectName("graphicsView")
        self.label1 = QtWidgets.QLabel(self.centralwidget)
        self.label1.setGeometry(QtCore.QRect(160, 460, 71, 16))
        self.label1.setObjectName("label1")
        self.label2 = QtWidgets.QLabel(self.centralwidget)
        self.label2.setGeometry(QtCore.QRect(160, 480, 47, 13))
        self.label2.setObjectName("label2")
        self.label3 = QtWidgets.QLabel(self.centralwidget)
        self.label3.setGeometry(QtCore.QRect(160, 500, 47, 13))
        self.label3.setObjectName("label3")
        self.listWidget = QtWidgets.QListWidget(self.centralwidget)
        self.listWidget.setGeometry(QtCore.QRect(620, 10, 141, 441))
        self.listWidget.setObjectName("listWidget")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 799, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        
        loop = asyncio.get_event_loop()
        self.thread1 = RSSI(loop)
        self.thread = Worker()
        self.thread1.work()
        self.thread.start()
        self.thread.signal.connect(self.gui_update)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label1.setText(_translate("MainWindow", "TextLabel"))
        self.label2.setText(_translate("MainWindow", "TextLabel"))
        self.label3.setText(_translate("MainWindow", "TextLabel"))
        
    def gui_update(self, result):
        x_data = result[0]
        y_data = result[1]
        scatter = pg.ScatterPlotItem(x_data, y_data,
            size=10, brush=[pg.mkBrush(c) for c in "rgb"])
        self.graphicsView.clear()
        self.graphicsView.addItem(scatter)
        self.graphicsView.setXRange(0,8, padding=0)
        self.graphicsView.setYRange(0,8, padding=0)

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    loop = QEventLoop(app)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    with loop:
        loop.run_forever()
    # sys.exit(app.exec_())
